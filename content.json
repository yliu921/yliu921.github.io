{"meta":{"title":"Yifei Liu","subtitle":"","description":"","author":"Yifei Liu","url":"https://yifeiliu.dev","root":"/"},"pages":[{"title":"","date":"2024-01-01T06:00:01.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"about/index.html","permalink":"https://yifeiliu.dev/about/index.html","excerpt":"","text":"About Tinker. Firefighter. Engineer."},{"title":"tags","date":"2024-01-02T04:23:03.000Z","updated":"2024-10-04T01:44:36.312Z","comments":true,"path":"tags/index.html","permalink":"https://yifeiliu.dev/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2024-10-04T01:44:36.308Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/10/03/hello-world/","permalink":"https://yifeiliu.dev/2024/10/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1hexo new &quot;My New Post&quot; More info: Writing Run server 1hexo server More info: Server Generate static files 1hexo generate More info: Generating Deploy to remote sites 1hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Xilinx FPGA Timing Constraint","slug":"Xilinx-FPGA-Timing-Constraint","date":"2024-03-23T16:01:58.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/03/23/Xilinx-FPGA-Timing-Constraint/","permalink":"https://yifeiliu.dev/2024/03/23/Xilinx-FPGA-Timing-Constraint/","excerpt":"","text":"Timing Constraint Timing Setup time: Hold time: Skew time: Jitter Timing Path There are 4 timing path in FPGA: 2 intra-chip and 2 inter-chip path. Path Start point End point Constraint Input port to the 1st register ChipA/clk RegA/D set_input_delay Path between registers RegA/clk RegB/D create_clock Last register to output port RegB/clk ChipB/D set_output_delay Input to output path DinA DinB set_max_delay Timing Model Constraint on setup and hold time I/O Constraint PIN constraint PACKAGE_PIN: physical location of the pin IO_IOSTANDARD: voltage DIFF_TERM: Differential term 1set_property -dict &#123;PACKAGE_PIN AJ16 IOSTANDARD LVCOMS18&#125; [get_ports &quot;led[0]&quot;] Constraint on input and output set_input_delay and set_output_delay Clock Constraint create_clock 1create_clock -name &lt;name&gt; -period &lt;period&gt; -waveform &#123;&lt;rise_time&gt; &lt;fall_time&gt;&#125; [get_ports &lt;input_port&gt;] Clock used here must be primary clock: external clock or the RXOUTCLK/TXOUTCLK from Gigabyte Transceiver Gigabyte (GT). The timing unit in create_clock is ns and 50% duty cycle by default. Using the report_clocks, we can check the constraint is valid or not. In general, the clock input is differential. We only need to constrain the P termination. If both P and n are constrained, report_clock_interaction will be report unsafe. This will incur the memory overhead, increasing After synthesize and implementation, use the following two methods to check the primary clock. 12report_clock_networks -name mainclockcheck_timing -override_defaults no_clock create_generated_clock set_clock_groups asynchronous multiple clock setting for the same clock network, -add BUFGMUX, apply mux to the input clocks. Virtual Clock Delay constraints for the I/O. Max/Min delay constraint.","categories":[],"tags":[]},{"title":"Scatter Gather DMA in Xilinx FPGA","slug":"Scatter-Gather-DMA","date":"2024-02-24T02:00:34.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/02/23/Scatter-Gather-DMA/","permalink":"https://yifeiliu.dev/2024/02/23/Scatter-Gather-DMA/","excerpt":"","text":"Introduction Naming convetion and System diagram Register in Xilinx DMA IP Scatter Gather Descriptor The descriptor is made up of eight 32-bit base words and 0 or 5 User Application words. The Buffer Length can describe up to 67,108,863 bytes of data buffer per descriptor. 123456789101112131415Descriptor Fields (Non-multichannel Mode)Address Space Offset (1) Name Description00h NXTDESC Next Descriptor Pointer04h NXTDESC_MSB Upper 32 bits of Next Descriptor Pointer08h BUFFER_ADDRESS Buffer Address0Ch BUFFER_ADDRESS_MSB Upper 32 bits of Buffer Address.10h RESERVED N/A14h RESERVED N/A18h CONTROL Control1Ch STATUS Status20h APP0 User Application Field 0 (2)24h APP1 User Application Field 128h APP2 User Application Field 22Ch APP3 User Application Field 330h APP4 User Application Field 4 Data Structure for Scatter Gather Descriptor 1234567891011121314151617struct sg_bd&#123; unsigned int nxtdesc;// unsigned int nxtdesc_msb; unsigned int buf_addr; // address of the data to trasnfer from memory map to stream, // should be aligned to the memory map data width unsigned int buf_addr_msb;// unsigned int reserved0; unsigned int reserved1; unsigned int ctrl; // 0x1c unsigned int status; unsigned int app0 ; unsigned int app1 ; unsigned int app2; unsigned int app3; unsigned int app4; unsigned int dummy[3];&#125;; MM2S_CONTROL register (0x18h) The value of thie register provides control for MM2S transfers from memory map to stream. 1234567Bits Field Name Description25 to 0 Buffer Length Indicates the size in bytes of the transfer buffer.26 Transmit End Of Frame End of Frame. Flag indicating the last buffer to be processed. • 0 = Not End of Frame. • 1 = End of Frame.27 TXSOF Start of Frame. Flag indicating the first buffer to be processed.","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/tags/FPGA/"}]},{"title":"Wifi Sniffer","slug":"Wifi-Sniffer","date":"2024-02-17T00:54:59.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/02/16/Wifi-Sniffer/","permalink":"https://yifeiliu.dev/2024/02/16/Wifi-Sniffer/","excerpt":"","text":"Install aircrack-ng on Ubuntu 1sudo apt install aircrack-ng -y Check the wifi adapter supports the Monitor mode or not. 123456$ sudo airmon-ngPHY Interface Driver Chipsetphy0 wlp0s20f3 iwlwifi Intelphy1 wlx3c rtl8814au TRENDnet &lt;- Will use this wifi adapter","categories":[],"tags":[]},{"title":"1. Linux driver development","slug":"1-Linux-driver-development","date":"2024-02-11T05:52:13.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/02/10/1-Linux-driver-development/","permalink":"https://yifeiliu.dev/2024/02/10/1-Linux-driver-development/","excerpt":"","text":"driver development Device tree brief File I/O to driver ref: https://lwn.net/Kernel/LDD3/","categories":[],"tags":[]},{"title":"Use FMC expansion for GPIO","slug":"Use-FMC-expansion-board-as-GPIO","date":"2024-01-28T22:39:44.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/28/Use-FMC-expansion-board-as-GPIO/","permalink":"https://yifeiliu.dev/2024/01/28/Use-FMC-expansion-board-as-GPIO/","excerpt":"","text":"This post will introduce how to use it as a GPIO board with a clock divider example. This work will use the following devices: ZCU106 FPGA board ALINX FH1010 expansion Ports Digilent Analog Discovery 2 The software will be used: Vivado 2020.2 and petalinux Xilinx system controller Clock divider design Create an AXI-Lite IP and modify the axi interface IO. The AXI Lite IP comes with 4 registers and we will use the register 0 to store the the dividend. 1234module clk_div_v1 ( // axi ports input clk, output clk_div); Modify the AXI IP 123456789101112131415161718192021222324module clk_div_v1_S00_AXI( // axi ports input clk, output reg clk_div); // Add user logic here reg [31:0]cnt; wire en = slv_reg0 != 0; // slv_reg0 is the register 0. When it&#x27;s 0, we would disable the clock divider. always @(posedge clk) begin if(~S_AXI_ARESETN) begin cnt &lt;= 32&#x27;h0000_0000; clk_div &lt;= 1&#x27;b0; end else if(en) begin if(cnt == slv_reg0 &gt;&gt;1) begin // every slv_reg0/2, flip the output clock clk_div &lt;= ~clk_div; cnt &lt;= 32&#x27;h0000_0000; end else cnt &lt;= cnt + 32&#x27;h0000_0001; end end // end user logicendmodule Block Design Create the block as following: Add Clocking Wizard IP and set the clk_out1 to 10MHz. Create the user constraint file for the generated clock and I/O: 123set_property IOSTANDARD LVCMOS18 [get_ports clk_div]set_property PACKAGE_PIN B11 [get_ports clk_div]create_clock -name clk_out1 -period 100ns In this example, we are using the LA23_P I/O port to output the generated clock to the oscilloscope. LA23_P can be used as a single ended I/O and it’s voltage is set to 1.8V. It’s connected to the PIN8 of J2 in the ALINX expansion board. The connection between the FPGA I/O pin to the expansion board can be found at UG1244 and FL1010 user manual. Next synthesis the project in Vivado and generate the firmware in Petalinux. Setup the Vadj of the FPGA In ZCU106, the configuration of Vadj affects the output voltage of the I/O ports in the expansion board. However, it’s 0V by default. Therefore, we need to use the System Control application (in the pre-request) to configure the ZCU106 before using the I/O ports. This step needs a Windows PC to run the application. To setup the Vadj just click the button Configuration the Vadj Boot and Test the IO The address the memory-mapped register of the clock divider IP is mapped to the 0xA0000000. After booting the fpga (with firmware), ssh into the FPGA. 12$ devmem 0xA0000000 w 1000 # write a word to the memory mapped register # it&#x27;s divided the clk_out1 (10MHz) with 1000 The output looks like this:","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/tags/FPGA/"}]},{"title":"Usage of bash script","slug":"Usage-of-bash-script","date":"2024-01-22T00:57:11.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/21/Usage-of-bash-script/","permalink":"https://yifeiliu.dev/2024/01/21/Usage-of-bash-script/","excerpt":"","text":"slepp function 1sleep 5d 1h 2m 30s where: s: seconds m: minutes h: hours d: days","categories":[],"tags":[{"name":"bash","slug":"bash","permalink":"https://yifeiliu.dev/tags/bash/"}]},{"title":"The Graphics Pipeline","slug":"The-Graphics-Pipeline","date":"2024-01-17T02:24:45.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/16/The-Graphics-Pipeline/","permalink":"https://yifeiliu.dev/2024/01/16/The-Graphics-Pipeline/","excerpt":"","text":"The graphics pipeline is another approach to rendering: drawing objects one by one onto the screen, or object-order rendering. Unlike in ray tracing, where we consider each pixel in turn and find the objects that influence its color, we will instead consider each geometric object in turn and find the pixels that it could have an effect on. The process of finding all the pixels in an image that are occupied by a geometric primitive is called rasterization. So object-order rendering can also be called rendering by rasterization. The sequence of operations is starting with objects and ending by updating pixels in the image, namely graphics pipeline. Hardware pipelines must run fast enough to react in real time for games, visualizations, and user interfaces. Production pipelines must render the highest quality animation and visual effects possible and scale to enormous scenes, but may take much more time. The work that needs to be done in object-order rendering can be organized into the task of rasterization itself, the operations that are done to geometry before rasterization, and the operations that are done to pixels after rasterization. The most common geometric operation is applying matrix transformations to map the points that define the geometry from object space to screen space, so that the input to the rasterizer is expressed in pixel coordinates, or screen space. The most common pixelwise operation is hidden surface removal which arranges for surfaces closer to the viewer to appear in front of surfaces farther from the viewer. Geometric objects are fed into the pipeline from an interactive application or from a scene description file, and they are always described by sets of vertices. The vertices are operated on in the vertex-procssing stage, then the primitives using those vertices are sent to the rasterization stage. The rasterizer breaks each primitive into a number of fragments, one for each pixel covered by the primitive. The fragments are processed in the fragment processing stage, and then the various fragments corresponding to each pixel are combined in the fragment blending stage. Rasterization For each primitive that comes in, the rasterizer has two jobs: enumerating the pixels that are covered by the primitive; then, interpolating values, called attributes, across the primitive. The output of the rasterizer is a set of fragments, one for each pixel covered by the primitive. Each fragment lives at a particular pixel and carries its own set of attribute values. Line Drawing For general screen coordinate endpoints (x0,y0)(x_0, y_0)(x0​,y0​), (x1,y1)(x_1, y_1)(x1​,y1​), the routine should draw some reasonable set of pixels that approximate a line between them. Line drawing using implicit line equations The most common way is the midpoint algorithm. The midpoint algorithm ends up drawing the same lines as the Bresenham alogithm, but more straight forward. The first thing is to find the implicit equation for the line as discussed in f(x,y)≡(y0−y1)x+(x1−x0)y+x0y1−x1y0=0f(x,y) \\equiv (y_0 - y_1)x + (x_1 - x_0)y + x_0y_1 - x_1y_0 = 0f(x,y)≡(y0​−y1​)x+(x1​−x0​)y+x0​y1​−x1​y0​=0. Nexy, we assume the slop of the line m∈(0,1]m \\in (0,1]m∈(0,1] where the line is moving faster in xxx than in yyy. The key assumption of the midpoint algorithm is that we draw thinnest line possible that has no gaps. A diagonal connection between two pixels is not considered a gap. The midpoint algorithm for m∈(0,1]m \\in (0,1]m∈(0,1] first estabilishes the left most point. Triangle Rasterization Barycentric coordinates -&gt; color redering. Another subtlety of rasterizing trangles is that we are usually rasterizing triangles that share vertices and edges.","categories":[{"name":"Computer Graphic","slug":"Computer-Graphic","permalink":"https://yifeiliu.dev/categories/Computer-Graphic/"}],"tags":[{"name":"Raterization","slug":"Raterization","permalink":"https://yifeiliu.dev/tags/Raterization/"}]},{"title":"0. Driver Development for Xilinx MPSoC FPGA","slug":"Create-driver-for-Xilinx","date":"2024-01-15T21:59:46.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/15/Create-driver-for-Xilinx/","permalink":"https://yifeiliu.dev/2024/01/15/Create-driver-for-Xilinx/","excerpt":"","text":"0. Create a kernel module using petalinux Use the command below to create a kernel module 123456petalinux -t modules --name ktest --enable[Usage]petalinux-create -t modules --name mymodule --enable -t type: project, apps, modules --name, -n specify the name for a component or project --enable enable the apps or modules for the project This command will creat the file and directory project-spec/meta-user/recipes-modules/ktest as following 1234| files| - ktest.c| - Makefile| ktest.bb 1. Modify the base module We first modify the ktest.c file in the directory files: 1234567891011121314151617181920212223242526272829#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/proc_fs.h&gt;// Module metadataMODULE_DESCRIPTION(&quot;Hello world driver&quot;);MODULE_LICENSE(&quot;GPL&quot;);// Custom init and exit methodsstatic int __init custom_init(void) &#123; /*When a function is declared as static in C, it means that the function has internal linkage, which restricts its visibility to the translation unit (source file) where it is defined. In other words, the function is only accessible within the same source file.*/ printk(KERN_INFO &quot;Hello world driver loaded.\\n&quot;); return 0;&#125;static void __exit custom_exit(void) &#123; printk(KERN_INFO &quot;Goodbye my friend...\\n&quot;);&#125;// Register the init and exit function// module_init() will either be called during do_initcalls() (if builtin)// or at module insertion time (if a module). There can only be one per module.module_init(custom_init);// module_exit() will wrap the driver clean-up code with cleanup_module() when // used with rmmod when the driver is a module. If the driver is statically // compiled into the kernel, module_exit() has no effect. There can only be one // per module.module_exit(custom_exit); Then, we update the ktest.bb with appending the following configuration: 1KERNEL_MODULE_AUTOLOAD += &quot;ktest&quot; This configuration will automatically load the kernel while booting. 2. Compile the kernel image and boot 3. Test the kernel After booting the kernel, 1234$ dmesg | grep &quot;Hello&quot;[ 19.061541] Hello world driver loaded.$ rmmod ktest &amp;&amp; dmesg | grep &quot;Goodbye&quot;[ 97.127431] Goodbye my friend...","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/tags/FPGA/"},{"name":"Linux","slug":"Linux","permalink":"https://yifeiliu.dev/tags/Linux/"}]},{"title":"Generate persistent ssh key for Xilinx MPSoC Linux (XLNX)","slug":"Generate-persistent-ssh-key-for-Xilinx-MPSoC-Linux-XLNXw","date":"2024-01-08T16:27:49.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/08/Generate-persistent-ssh-key-for-Xilinx-MPSoC-Linux-XLNXw/","permalink":"https://yifeiliu.dev/2024/01/08/Generate-persistent-ssh-key-for-Xilinx-MPSoC-Linux-XLNXw/","excerpt":"","text":"Here is some background information and methodology on how to store SSH keys on persistent storage, and modify init scripts such that the petalinux image does not generate a new key on each boot: This sequence of steps describes how to use the flash MTD partition for persistent storage. The use case being considered is to load a previously generated RSA key and prevent dropbear from generating a new one (the dropbear init script needs to be modified for doing this). The Dropbear SSH server is included by default in Petalinux, and is built automatically into the rootfs. Upon boot up, the dropbear init script (named dropbear) is placed and executes from the /etc/init.d directory: This script has a function gen_keys(), which is responsible for generating the RSA key. If a key already exists at /etc/dropbear, the gen_keys() function first deletes this key, and then generates a new one. Although not recommended by Xilinx officially, there might be some use cases where this functionality is not desired. For example, when a user wants to avoid having new keys generated upon reboot, and instead loads them from persistent storage. In such cases, a custom recipe named dropbear can be added to the Petalinux project, with a custom init script that suppresses the call to gen_keys(). When the image is built and run from the board, the new dropbear init script will run and not create new keys at /etc/dropbear. The user can then copy over a previously generated key into this location from persistent storage. This methodology can be dvivded into two parts: Generate a RSA key (on the board or laptop) and store it in the persistent storage (QSPI Flash) on the FPGA. Boot up with the modified dropbear init script, mount the QSPI Flash device on a JFFS partition, and copy over the previously stored key into /etc/dropbear. Part 1: Build a normal Petalinux project and use those images to boot into the board. Default kernel config settings should include ZynqMP GQSPI as well as MTD block device support. From the Linux terminal, issue dmesg | grep spi and verify that four MTD partitions were created. Follow this by cat /proc/mtd to view the partitions. We will use the ‘spare’ MTD partition /dev/mtd3 for persistent storage. Erase /dev/mtd3 partition using flash_eraseall -j /dev/mtd3. Create a mount point for the flash partition: mkdir /mnt/flash_mtd3. Mount flash partition as JFFS2 file system: mount -t jffs2 /dev/mtdblock3 /mnt/flash_mtd3. (Note that /dev/mtdblock3 is used rather than /dev/mtd3) Copy Dropbear RSA key to flash partition: cp /etc/dropbear/dropbear_rsa_host_key /mnt/flash_mtd3 Verify the copied key exists on the flash partition: ls /mnt/flash_mtd3. Unmount flash partition: umount /mnt/flash_mtd3. The Dropbear RSA key now resides in the persistent flash storage and can be accessed on successive boots The existing Dropbear init script can be modified and used in Part 2. Copy the script (/etc/init.d/dropbear) over to your host machine. Part 2: Go back to your Petalinux project, and add a folder named ‘dropbear’ to &lt;plnx_proj_root&gt;/project-spec/meta-user/recipes-core/. Within this folder, build the following structure: 1234├── dropbear│ ├── dropbear_%.bbappend│ └── files│ └── dropbear.initd The dropbear init script in the ‘files’ folder above is the one you have copied over from Part 1, and modified by modifying the gen_keys(). 12345678910111213141516171819gen_keys() &#123; mkdir -p /mnt/qspi_mtd3 mount -t jffs2 /dev/mtdblock3 /mnt/qspi_mtd3 if [ -f &quot;/mnt/qspi_mtd3/dropbear_rsa_host_key&quot; ]; then mkdir -p $DROPBEAR_RSAKEY_DIR cp /mnt/qspi_mtd3/dropbear_rsa_host_key $DROPBEAR_RSAKEY else if [ -f &quot;$DROPBEAR_RSAKEY&quot; -a ! -s &quot;$DROPBEAR_RSAKEY&quot; ]; then rm $DROPBEAR_RSAKEY || true fi if [ ! -f &quot;$DROPBEAR_RSAKEY&quot; ]; then mkdir -p $&#123;DROPBEAR_RSAKEY%/*&#125; dropbearkey -t rsa -f $DROPBEAR_RSAKEY $DROPBEAR_RSAKEY_ARGS fi cp $DROPBEAR_RSAKEY /mnt/qspi_mtd3 fi umount /mnt/qspi_mtd3&#125; Create dropbear_%.bbappend as follows: 1234567891011# The dropbear_%.bbappend looks like this:# Dropbear: suppress gen_keys.SRC_URI_append = &quot; \\ file://dropbear.initd \\ &quot;FILESEXTRAPATHS_prepend := &quot;$&#123;THISDIR&#125;/files:&quot; # Overwrite the dropbear configuration with my configuration.do_install_append() &#123; install -m 0755 $&#123;WORKDIR&#125;/dropbear.initd $&#123;D&#125;$&#123;sysconfdir&#125;/init.d/dropbear&#125; Add the line SIGGEN_UNLOCKED_RECIPES_append = &quot;dropbear&quot; to &lt;plnx_proj_root&gt;/project-spec/meta-user/conf/petalinuxbsp.conf. Clean the Petalinux project and re-build: petalinux-build -x mrproper and petalinux-build. Boot with the generated images. Observe that the key generation message is not displayed, and no key will exist at /etc/dropbear. Mount flash partition containing original key: mount -t jffs2 /dev/mtdblock3 /mnt/flash_mtd3 Copy key into default location: cp /mnt/flash_mtd3/dropbear_rsa_host_key /etc/dropbear","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/tags/FPGA/"}]},{"title":"TFTP for Xilinx ZCU106","slug":"TFTP-for-Xilinx-ZCU106","date":"2024-01-07T19:05:16.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/07/TFTP-for-Xilinx-ZCU106/","permalink":"https://yifeiliu.dev/2024/01/07/TFTP-for-Xilinx-ZCU106/","excerpt":"","text":"Setup in Petalinux Launch the top-level system configuration menu. 1petalinux-config Select Image Packaging Configuration. Select Copy final images to tftpboot and set tftpboot directory. By default, the TFTP directory ID is /tftpboot. Ensure this matches the TFTP server setup of your host. Build the project Setup the FPGA into JTAG mode Config the FPGA into JTAG mode. Boot from ethernet 1petalinux-boot --jtag --u-boot --fpga --bitstream images/linux/system.bit Log Connect to the ZCU106 through the UART. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Release 2020.2 Jan 7 2024 - 21:10:37NOTICE: ATF running on XCZU7EV/silicon v4/RTL5.1 at 0xfffea000NOTICE: BL31: v2.2(release):xlnx_rebase_v2.2_2020.3NOTICE: BL31: Built : 21:09:55, Jan 7 2024U-Boot 2020.01 (Jan 07 2024 - 21:11:18 +0000)Model: ZynqMP ZCU106 RevABoard: Xilinx ZynqMP DRAM: 4 GiBPMUFW: v1.1EL Level: EL2Chip ID: zu7ev NAND: 0 MiBMMC: mmc@ff170000: 0 In: serial@ff000000 Out: serial@ff000000 Err: serial@ff000000 Bootmode: JTAG_MODEReset reason: EXTERNALNet:ZYNQ GEM: ff0e0000, mdio bus ff0e0000, phyaddr 12, interface rgmii-idWarning: ethernet@ff0e0000 using MAC address from ROMeth0: ethernet@ff0e0000Hit any key to stop autoboot: 0JTAG: Trying to boot script at 0x20000000## Executing script at 20000000Wrong image format for &quot;source&quot; commandJTAG: SCRIPT FAILED: continuing...starting USB...Bus dwc3@fe200000: usb maximum-speed not foundRegister 2000440 NbrPorts 2Starting the controllerUSB XHCI 1.00scanning bus dwc3@fe200000 for devices... 1 USB Device(s) found scanning usb for storage devices... 0 Storage Device(s) foundethernet@ff0e0000 Waiting for PHY auto negotiation to complete........... doneBOOTP broadcast 1BOOTP broadcast 2BOOTP broadcast 3DHCP client bound to address 10.42.0.65 (766 ms)*** Warning: no boot file name; using &#x27;0A2A0041.img&#x27;Using ethernet@ff0e0000 deviceTFTP from server 10.42.0.1; our IP address is 10.42.0.65Filename &#x27;0A2A0041.img&#x27;.Load address: 0x8000000Loading: *TFTP error: &#x27;File not found&#x27; (1)Not retrying...missing environment variable: pxeuuidmissing environment variable: bootfileRetrieving file: pxelinux.cfg/01-00-0a-35-07-13-54Using ethernet@ff0e0000 deviceTFTP from server 10.42.0.1; our IP address is 10.42.0.65Filename &#x27;pxelinux.cfg/01-00-0a-35-07-13-54&#x27;. Issue The boot of linux is OK. But when I enable packagegroup-core-buildessential-dbg and packagegroup-core-buildessential-dev in rootfs, I came across the error boot.scr.uimg not found.","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/tags/FPGA/"},{"name":"TFTP","slug":"TFTP","permalink":"https://yifeiliu.dev/tags/TFTP/"}]},{"title":"2. Using OOP in SystemVerilog","slug":"Using-OOP-in-SystemVerilog","date":"2024-01-05T01:46:29.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/04/Using-OOP-in-SystemVerilog/","permalink":"https://yifeiliu.dev/2024/01/04/Using-OOP-in-SystemVerilog/","excerpt":"","text":"Using Obejcts Using class in Sv is analogy to C++, refering to variables and routines in an object with the . notation. 1234BusTran b;b = new;b.addr = 32&#x27;h42;b.dispaly(); // Call a routine In strict OOP, the only access to variables in an object should be through its public methods such as get() and put(). While the get() and put() methods are fine for compilers, GUIs, and APIs, you should stick with public variables that can be directly accessed anywhere in the testbench. Static Variables vs. Global Variables Sometimes, we need a variable that is shared by all objects of a certain type. Without OOP, we would probably create a global variable, which is used by one small piece of code, but is visible to the entire testbench. Using Static variable Example, creating static variable inside a class. 123456789101112131415class BusTran; static int count = 0; // Number of objects created, shared across objects. int id; // not static, each object has its own copy. // track objects flow through design // Unique instance ID function new; // COnstructor id = count++; // Set ID, and change the value of count endfunctionendclassBusTran b1, b2;initial begin b1 = new; // First object, id = 0; b2 = new; // 2nd object, id = 1;end Each time a new object is constructed, it is tagged with a unique value, and count is incremented. SystemVerilog does not allow printing the address of an object, but we can create an ID field. Whenever tempting to make a global variable, consider making a class-level static variable. Initializing static variables Cannot do this in the class constructor, because it’s called for every single new object. Intead, using the initial block before the first object is constructed. 123456789101112class static; static int count; task initialize(int val); count = val; endtaskendclassstatic s; // s is still a null pointerinitial begin s.initialize(42); // This is legal, as the task only uses static variables // that are not created in the constructorend Class Routines (Method) A routine (a.k.a. method) in a class is just a task or function defined inside the scope of the class. Define Routines Outside of the Class 1234567891011121314151617181920212223242526272829class BusTran; bit [31:0] addr, crc, data[8]; extern function void display();endclass// class body(BusTran) class scope opertater(::) method(display)function void BusTran::display(); // this is a prototype $display(&quot;@%0d: BusTran addr=%h, crc=%h&quot;, addr, crc); $write(&quot;\\tdata[0-7]=&quot;); foreach (data[i]) $write(data[i]); $display();endfunctionclass PCI_Tran; bit [31:0] addr, data; // Use realistic names extern function void display();endclassfunction void PCI_Tran::display(); $display(&quot;@%0d: PCI: addr=%h, data=%h&quot;, addr, data);endfunctionclass Broken; int id; extern function void display;endclassfunction void display; // Missing Broken:: $display(&quot;Broken: id=%0d&quot;, id); // Error, id not foundendfunction Scoping rules A scope is a block of code such as a module, program, task, function, class, or begin - end block. The for and foreach loops automatically create a block so that an index variable can be declared or created local to the scope of the loop. Declare all your variables in the smallest scope that encloses all uses of the variable. Using One class Inside Another 12345678910111213class BusTran; bit [31:0]addr, crc, data[8]; Statistics stats; // a hanlder of another class // remember to instantiaste the objects, // otherwise stats os null and the call to start fails. function new(); stats = new(); // best to instantiate in the constructor endfunction task create_packet(); stats.start(); endtaskendclass Compilation order issue Sometimes you need to compile a class that includes another class that is not yet defined. The declaration of the included class’s handle causes an error, as the compiler does not recognize the new type. Declare the class name with a typedef statement, as shown below. 12345678typedef class Statistics;class BusTran;Statistics stats;...endclassclass Statistics;...endclass Dynamic Obejcts Use ref to pass the address of scalar variable (noarray, nonobject), so the routine can modify it. 1234567891011// Transmit a packet onto a 32-bit bustask transmit(BusTran bt); CBbus.rx_data &lt;= bt.data; bt.timestamp = $time; // cannot modify the handle, need to use refendtaskBusTran b;initial begin b = new(); b.addr = 42; transmit(b);end Modifying objects in flight A very common mistake is forgetting to create a new object for each transaction in the testbench, 123456789101112task generator_bad(int n); BusTran b; b = new(); // Create one new object repeat (n) begin b.addr = $random(); // Initialize variables $display(&quot;Sending addr=%h&quot;, b.addr); transmit(b); // Send it into the DUT endendtask So every time through the loop, generator_bad changes the object at the same time it is being transmitted. When you run this, the $display shows many addr values, but all transmitted BusTrans have the same value of addr. The bug occurs if transmit stores the object and keeps using it even after transmit returns. If your transmit task does not keep a reference to the object, you can recycle the same object over and over. 123456789task generator_good(int n); BusTran b; repeat (n) begin b = new(); // Create one new object b.addr = $random();// Initialize variables $display(&quot;Sending addr=%h&quot;, b.addr); transmit(b); // Send it into the DUT endendtask You can make arrays of handles, each of which refers to an object, e.g., BusTran Barray[10]. Copying objects You may want to make a copy of an object to keep a routine from modifying the original, or in a generator to preserve the constraints. You can either use the simple, built-in copy available with new , or you can write your own for more complex classes. 123456789class BusTrain;...endclassBusTran src, dst;initial begin src = new; dst = new src;end This is a shallow copy, blindly transcribing values from source to destination. If the class contains a handle to another class, only the top level object is copied by new, not the lower level one. Example as following, 1234567891011121314151617181920class BusTran; bit [31:0] addr, crc, data[8]; static int count = 0; int id; Statistics stats; function new; stats = new; id = count++; endfunctionendclassBusTran src, dst;initial begin src = new; // Create first object src.stats.startT = 42; dst = new src; // Copy src to dst dst.stats.startT = 84; // Changes stats for dst &amp; srcend Note: it doesn’t call the custormized new function. both objects point to the same Statistics object and both have the same id. Writing your own simple copy function 123456789101112131415161718class BusTran; bit [31:0] addr, crc, data[8]; Statistics stats; static int count = 0; int id; function new; stats = new; id = count++; endfunction function BusTran copy; copy = new; copy.addr = addr; copy.crc = crc; copy.data = data; copy.stats = stats.copy; id = count++; endfunctionendclass Note that you also need to write a copy for the Statistics class, and every other class in the hierarchy.","categories":[{"name":"SystemVerilog Tutorial","slug":"SystemVerilog-Tutorial","permalink":"https://yifeiliu.dev/categories/SystemVerilog-Tutorial/"}],"tags":[{"name":"SystemVerilog","slug":"SystemVerilog","permalink":"https://yifeiliu.dev/tags/SystemVerilog/"}]},{"title":"What is uid, euid in Linux","slug":"uid-euid-in-Linux","date":"2024-01-04T21:00:09.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/04/uid-euid-in-Linux/","permalink":"https://yifeiliu.dev/2024/01/04/uid-euid-in-Linux/","excerpt":"","text":"UID The UID, or User ID, is the real user identifier associated with a process. It represents the user who launched the process. The UID can be got using getuid() function or using id in bash. 1234567#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; uid_t uid = getuid(); printf(&quot;UID: %u\\n&quot;, uid); return 0;&#125; The UID is generally set at the beginning of a process and remains constant throughout the process’s lifetime. The UID is used for various permission checks and to determine ownership of files and processes. EUID The EUID, or Effective User ID, is a separate user identifier that can be changed during the execution of a process, using using system calls like seteuid() or setreuid() to temporarily gain or relinquish certain privileges. Typically, only processes running as the superuser (UID 0) or with the setuid permission can change their effective user ID 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; // Attempt to set the effective user ID to 0 (root) if (seteuid(0) == 0) &#123; printf(&quot;Successfully set the effective UID to 0 (root).\\n&quot;); // After performing the privileged operations, you should reset the effective UID // to the original value using seteuid(getuid()) for security reasons. seteuid(getuid()); &#125; else &#123; perror(&quot;seteuid&quot;); exit(EXIT_FAILURE); &#125; return 0;&#125; The EUID is used for most permission checks in the kernel and is what determines the process’s effective privileges. When a process is executed, the EUID is often initially set to the UID of the user who launched the process, that can be derived from geteuid() (notice the e before uid) system call or echo $EUID in bash. In most Unix-like systems: UID 0 is reserved for the root user (superuser). UID 1-99 are often reserved for system users and groups. UID 1000 and above are typically assigned to regular user accounts.","categories":[{"name":"Usage of Linux","slug":"Usage-of-Linux","permalink":"https://yifeiliu.dev/categories/Usage-of-Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yifeiliu.dev/tags/Linux/"}]},{"title":"1. OOP in SystemVerilog","slug":"OOP-in-SystemVerilog","date":"2024-01-04T01:22:27.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/03/OOP-in-SystemVerilog/","permalink":"https://yifeiliu.dev/2024/01/03/OOP-in-SystemVerilog/","excerpt":"","text":"OOP Terminology Class: a basic building block containing routines and variables, it's analogue in Verilog is a module. Object: an instance of the class. In Verilog, instanitate a module to use it. Handle: a pointor to the object. In veriolog, it stands for the instance when refers to signal and methods from outstide the module. Property: a variable that holds data, such as a reg or wire in Verilog. Method: procedure code that manipulates variables, contained in tasks and functions. Verilog modules have tasks and functions plus initial and always blocks. Prototype: the head of a routine that shows the name, type and arugment list. The body of the routine contains the exectuable code. In Verilog you build complex designs by creating modules and instantiating them hierarchically. In OOP you create classes and instantiate them (creating objects) to create a similar hierarchy. Following is an example of a class: 123456789101112131415class Transaction; bit [31:0]addr, crc, data[8]; // Property function void display //Method $display(&quot;Transaction:%h&quot;, addr); endfunction: display function void calc_crc; crc = addr ^ data.xor; endfunction:calc_crcendclass:TransactionTransaction tr; // Declare a handler, it&#x27;s a nullTr = new(); // Allocate a Transaction object new allocate the space for the BusTran, initializes the variables to the default value, 0 for 2-state variables and X for 4-state ones, and returns the address where object is stored. The new function not only allocates memory but also initialize the values. We can also define the new function to set the values of variables. 123456789101112131415161718192021222324class BusTrain; logic [31:0]addr, crc, data[8]; function new(logic [31:0]addr=3,d=5); // does not have a type, as it always returns an objec of the same type // as the class // Sets addr and data to fixed values, but leaves crc as X. // SV allocate space for the object automatically. this.addr = addr; foreach(data[i]) data[i] = d; endfunctionendclassclass Driver; BusTran bt; function new(); // Driver&#x27;s new function bt = new(); // call the BusTran new function endfunctionendclassinitial begin BusTran b; b = new(10); // addr is initialized to 10, but data is default 5.end new() vs new[] new() can take arguments for setting object values, while new[] only takes single value for the array size. Object deallocation Garbage collection is the process of automatically freeing objects that are no longer referenced. SystemVerilog keeps tracking of the number of handles that point to it. When the last handle no longer references an object, SystemVerilog releases the memory for it. 12345BusTran b; // a handleb = new; // calles new to construct an object, allocate the first object // e.g., b points to the objectb = new; // Allocate the second one, free the first oneb = null&#x27; // Deallocate the second Note the differences with C++: SV handle can only point to objects of one type. C++ a typical untyped pointer is only an address in memory. SV doesn’t allow any modification of a handle or using a handle of one type to refer to an object of another type. Garbage collection in C/C++ is manual, suffering from “memory leaks” when forgets deallocating objects.","categories":[{"name":"SystemVerilog Tutorial","slug":"SystemVerilog-Tutorial","permalink":"https://yifeiliu.dev/categories/SystemVerilog-Tutorial/"}],"tags":[{"name":"SystemVerilog","slug":"SystemVerilog","permalink":"https://yifeiliu.dev/tags/SystemVerilog/"}]},{"title":"Why use pthread_cond_wait in a loop","slug":"Why-use-pthread-cond-wait-in-a-loop","date":"2024-01-02T03:40:17.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/01/Why-use-pthread-cond-wait-in-a-loop/","permalink":"https://yifeiliu.dev/2024/01/01/Why-use-pthread-cond-wait-in-a-loop/","excerpt":"","text":"In the producer and consumer model, we usually use pthread_cond_wait to put the thread into sleep while the execution is not statifised. For example, 12345678// When the product queue is full, put the producer into wait conditionwhile(q.size() == LIMIT_SIZE) &#123; pthread_cond_wait(&amp;notfull, &amp;lock); // When the not empty signal is receiver, wake up the thread.&#125;// Production code begin// xxxx// Production code end Instead of forwarding to the production code, thread goes back to the condition check in the while. Why? Follwing is an example, 123456789101112131415161718Thread 1 Thread 2 Thread 3q.size() == LIMIT (True)pthread_cond_wait: 1. unlock mutex 2. wait lock mutex set condition: not full pthread_cond_signal unlock mutex lock mutex check condition: not full 1. Doing staff 2. unset condition unlock mutexpthread_cond_wait: 1. wake up 2. lock mutex&lt;thread is awake, but condition is unset&gt; When thread 2 sends out the condition signal, there may be another thread, e.g., thread 3 may steal the conditional flag and disquailify the wake up condition. There is because the thread must release the mutex before waiting. Unless it is guaranteed that only one thread can wait on that condition, e.g., one producer and one consumer.","categories":[{"name":"Using pthread","slug":"Using-pthread","permalink":"https://yifeiliu.dev/categories/Using-pthread/"}],"tags":[{"name":"pthread","slug":"pthread","permalink":"https://yifeiliu.dev/tags/pthread/"}]},{"title":"Writing plan of 2024","slug":"Writing-plan","date":"2024-01-01T06:00:01.000Z","updated":"2024-10-04T01:44:36.308Z","comments":true,"path":"2024/01/01/Writing-plan/","permalink":"https://yifeiliu.dev/2024/01/01/Writing-plan/","excerpt":"","text":"iToF sensor stereo calibration RGB+iToF calibration Image Singal Pipeline SystemVerilog verification tutroial OS scheduling Neural Network accelartor Super-Scalar processor PCIE usage Color correction Link, Assemble Digital VLSI","categories":[{"name":"plan","slug":"plan","permalink":"https://yifeiliu.dev/categories/plan/"}],"tags":[{"name":"Writing Plan","slug":"Writing-Plan","permalink":"https://yifeiliu.dev/tags/Writing-Plan/"}]}],"categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/categories/FPGA/"},{"name":"Computer Graphic","slug":"Computer-Graphic","permalink":"https://yifeiliu.dev/categories/Computer-Graphic/"},{"name":"SystemVerilog Tutorial","slug":"SystemVerilog-Tutorial","permalink":"https://yifeiliu.dev/categories/SystemVerilog-Tutorial/"},{"name":"Usage of Linux","slug":"Usage-of-Linux","permalink":"https://yifeiliu.dev/categories/Usage-of-Linux/"},{"name":"Using pthread","slug":"Using-pthread","permalink":"https://yifeiliu.dev/categories/Using-pthread/"},{"name":"plan","slug":"plan","permalink":"https://yifeiliu.dev/categories/plan/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://yifeiliu.dev/tags/FPGA/"},{"name":"bash","slug":"bash","permalink":"https://yifeiliu.dev/tags/bash/"},{"name":"Raterization","slug":"Raterization","permalink":"https://yifeiliu.dev/tags/Raterization/"},{"name":"Linux","slug":"Linux","permalink":"https://yifeiliu.dev/tags/Linux/"},{"name":"TFTP","slug":"TFTP","permalink":"https://yifeiliu.dev/tags/TFTP/"},{"name":"SystemVerilog","slug":"SystemVerilog","permalink":"https://yifeiliu.dev/tags/SystemVerilog/"},{"name":"pthread","slug":"pthread","permalink":"https://yifeiliu.dev/tags/pthread/"},{"name":"Writing Plan","slug":"Writing-Plan","permalink":"https://yifeiliu.dev/tags/Writing-Plan/"}]}